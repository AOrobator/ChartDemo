package com.orobator.chartdemo;

import android.graphics.Paint;
import android.graphics.PorterDuff;
import android.graphics.PorterDuffXfermode;
import android.graphics.Matrix;
import android.graphics.RectF;
import android.graphics.Shader;
import android.graphics.LinearGradient;
import android.graphics.RadialGradient;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Path;
import android.graphics.DashPathEffect;
import java.util.Stack;
import java.util.Arrays;



/**
 * Created by Andrew Orobator on 5/16/17.
 * Copyright Â© 2017 7Park Data. All rights reserved.
 *
 * This code was generated by Trial version of PaintCode, therefore cannot be used for commercial purposes.
 * http://www.paintcodeapp.com
 *
 * @author Andrew Orobator
 */
public class CircleGraphStyleKit {
    private static class GlobalCache {
        static PorterDuffXfermode blendModeDestinationIn = new PorterDuffXfermode(PorterDuff.Mode.DST_IN);
    }
    
    // Resizing Behavior
    public enum ResizingBehavior {
        AspectFit, //!< The content is proportionally resized to fit into the target rectangle.
        AspectFill, //!< The content is proportionally resized to completely fill the target rectangle.
        Stretch, //!< The content is stretched to match the entire target rectangle.
        Center, //!< The content is centered in the target rectangle, but it is NOT resized.
    }
    
    // In Trial version of PaintCode, the code generation is limited to 3 canvases.
    
    // Canvas Drawings
    // Tab
    
    private static class CacheForCanvas1 {
        private static Paint paint = new Paint();
        private static PaintCodeGradient gradient = null;
        private static RectF originalFrame = new RectF(0f, 0f, 240f, 240f);
        private static RectF resizedFrame = new RectF();
        private static RectF colorOvalRect = new RectF();
        private static Path colorOvalPath = new Path();
        private static PaintCodeLinearGradient colorOvalPathGradient = new PaintCodeLinearGradient();
        private static RectF maskOvalRect = new RectF();
        private static Path maskOvalPath = new Path();
        private static PaintCodeDashPathEffect maskOvalPathDashEffect = new PaintCodeDashPathEffect();
    }
    
    public static void drawCanvas1(Canvas canvas, float colorFraction) {
        CircleGraphStyleKit.drawCanvas1(canvas, new RectF(0f, 0f, 240f, 240f), ResizingBehavior.AspectFit, colorFraction);
    }
    
    public static void drawCanvas1(Canvas canvas, RectF targetFrame, ResizingBehavior resizing, float colorFraction) {
        // General Declarations
        Stack<Matrix> currentTransformation = new Stack<Matrix>();
        currentTransformation.push(new Matrix());
        Paint paint = CacheForCanvas1.paint;
        
        // Local Colors
        int color3 = Color.argb(255, 0, 0, 0);
        
        // Local Gradients
        if (CacheForCanvas1.gradient == null)
            CacheForCanvas1.gradient = new PaintCodeGradient(new int[]{Color.BLUE, Color.RED}, new float[]{0f, 1f});
        PaintCodeGradient gradient = CacheForCanvas1.gradient;
        
        // Local Variables
        float colorDash = 475f * colorFraction;
        
        // Resize to Target Frame
        canvas.save();
        RectF resizedFrame = CacheForCanvas1.resizedFrame;
        CircleGraphStyleKit.resizingBehaviorApply(resizing, CacheForCanvas1.originalFrame, targetFrame, resizedFrame);
        canvas.translate(resizedFrame.left, resizedFrame.top);
        canvas.scale(resizedFrame.width() / 240f, resizedFrame.height() / 240f);
        
        // ColorOval
        RectF colorOvalRect = CacheForCanvas1.colorOvalRect;
        colorOvalRect.set(16f, 16f, 224f, 224f);
        Path colorOvalPath = CacheForCanvas1.colorOvalPath;
        colorOvalPath.reset();
        colorOvalPath.addOval(colorOvalRect, Path.Direction.CW);
        
        paint.reset();
        paint.setFlags(Paint.ANTI_ALIAS_FLAG);
        paint.setStyle(Paint.Style.FILL);
        paint.setShader(CacheForCanvas1.colorOvalPathGradient.get(gradient, 140.57f, 98.83f, 79.06f, 107.66f));
        canvas.drawPath(colorOvalPath, paint);
        
        // MaskOval
        
        paint.reset();
        paint.setFlags(Paint.ANTI_ALIAS_FLAG);
        paint.setXfermode(GlobalCache.blendModeDestinationIn);
        canvas.saveLayer(null, paint, Canvas.ALL_SAVE_FLAG);
        {
            canvas.translate(120f, 121f);
            currentTransformation.peek().postTranslate(120f, 121f);
            canvas.rotate(-90f);
            currentTransformation.peek().postRotate(-90f);
            RectF maskOvalRect = CacheForCanvas1.maskOvalRect;
            maskOvalRect.set(-75f, -76f, 75f, 74f);
            Path maskOvalPath = CacheForCanvas1.maskOvalPath;
            maskOvalPath.reset();
            maskOvalPath.moveTo(75f, -1f);
            maskOvalPath.cubicTo(75f, 40.42f, 41.42f, 74f, 0f, 74f);
            maskOvalPath.cubicTo(-41.42f, 74f, -75f, 40.42f, -75f, -1f);
            maskOvalPath.cubicTo(-75f, -42.42f, -41.42f, -76f, 0f, -76f);
            maskOvalPath.cubicTo(41.42f, -76f, 75f, -42.42f, 75f, -1f);
            maskOvalPath.close();
            
            paint.reset();
            paint.setFlags(Paint.ANTI_ALIAS_FLAG);
            paint.setStrokeWidth(6f);
            paint.setStrokeCap(Paint.Cap.ROUND);
            paint.setStrokeMiter(10f);
            paint.setPathEffect(CacheForCanvas1.maskOvalPathDashEffect.get(colorDash, 500f, 1f));
            canvas.save();
            paint.setStyle(Paint.Style.STROKE);
            paint.setColor(color3);
            canvas.drawPath(maskOvalPath, paint);
            canvas.restore();
        }
        canvas.restore();
        
        canvas.restore();
    }
    
    
    // Resizing Behavior
    public static void resizingBehaviorApply(ResizingBehavior behavior, RectF rect, RectF target, RectF result) {
        if (rect.equals(target) || target == null) {
            result.set(rect);
            return;
        }
        
        if (behavior == ResizingBehavior.Stretch) {
            result.set(target);
            return;
        }
        
        float xRatio = Math.abs(target.width() / rect.width());
        float yRatio = Math.abs(target.height() / rect.height());
        float scale = 0f;
        
        switch (behavior) {
            case AspectFit: {
                scale = Math.min(xRatio, yRatio);
                break;
            }
            case AspectFill: {
                scale = Math.max(xRatio, yRatio);
                break;
            }
            case Center: {
                scale = 1f;
                break;
            }
        }
        
        float newWidth = Math.abs(rect.width() * scale);
        float newHeight = Math.abs(rect.height() * scale);
        result.set(target.centerX() - newWidth / 2,
            target.centerY() - newHeight / 2,
            target.centerX() + newWidth / 2,
            target.centerY() + newHeight / 2);
    }
    
    
}

class PaintCodeGradient {
    private int[] colors;
    private float[] positions;
    
    public PaintCodeGradient(int[] colors, float[] positions) {
        if (positions == null) {
            int steps = colors.length;
            positions = new float[steps];
            for (int i = 0; i < steps; i++)
                positions[i] = (float) i / (steps - 1);
        }
        
        this.colors = colors;
        this.positions = positions;
    }
    
    public LinearGradient linearGradient(float x0, float y0, float x1, float y1) {
        return new LinearGradient(x0, y0, x1, y1, this.colors, this.positions, Shader.TileMode.CLAMP);
    }
    
    public RadialGradient radialGradient(float startX, float startY, float startRadius, float endX, float endY, float endRadius) {
        int steps = this.colors.length;
        float[] positions = new float[steps];
        
        if (startRadius > endRadius) {
            float ratio = endRadius / startRadius;
            int[] colors = new int[steps];
            
            for (int i = 0; i < steps; i++) {
                colors[i] = this.colors[steps - i - 1];
                positions[i] = (1 - this.positions[steps - i - 1]) * (1 - ratio) + ratio;
            }
            
            return new RadialGradient(endX, endY, startRadius, colors, positions, Shader.TileMode.CLAMP);
        } else {
            float ratio = startRadius / endRadius;
            
            for (int i = 0; i < steps; i++) {
                positions[i] = this.positions[i] * (1 - ratio) + ratio;
            }
            
            return new RadialGradient(startX, startY, endRadius, this.colors, positions, Shader.TileMode.CLAMP);
        }
    }
    
    @Override
    public boolean equals(Object obj) {
        if (!(obj instanceof PaintCodeGradient))
            return false;
        PaintCodeGradient other = (PaintCodeGradient) obj;
        return Arrays.equals(this.colors, other.colors) && Arrays.equals(this.positions, other.positions);
    }
}


class PaintCodeLinearGradient {
    private LinearGradient shader;
    private PaintCodeGradient paintCodeGradient;
    private float x0, y0, x1, y1;
    LinearGradient get(PaintCodeGradient paintCodeGradient, float x0, float y0, float x1, float y1) {
        if (this.shader == null || this.x0 != x0 || this.y0 != y0 || this.x1 != x1 || this.y1 != y1 || !this.paintCodeGradient.equals(paintCodeGradient)) {
            this.x0 = x0;
            this.y0 = y0;
            this.x1 = x1;
            this.y1 = y1;
            this.paintCodeGradient = paintCodeGradient;
            this.shader = paintCodeGradient.linearGradient(x0, y0, x1, y1);
        }
        return this.shader;
    }
}


class PaintCodeDashPathEffect {
    private DashPathEffect effect;
    private float dash, gap, phase;
    
    DashPathEffect get(float dash, float gap, float phase) {
        if (this.dash != dash || this.gap != gap || this.phase != phase) {
            this.dash = dash;
            this.gap = gap;
            this.phase = phase;
            this.effect = new DashPathEffect(new float[]{dash, gap}, phase);
        }
        return this.effect;
    }
}
